---
tags:
  - java
  - class_loader
  - jvm
aliases:
  - 클래스 로더
  - Class Loader
---
---
# 클래스 로더란?
- Java Classloader는 [[자바 클래스]]를 [[JVM|자바 가상 머신(JVM)]]으로 [[동적 로드]]/[[Dynamic Linking|동적 링킹]]하는 역할을 수행하는  [[JRE|자바 런타임 환경(JRE)]]의 일부이다.
	- 자바는 동적으로 클래스를 읽어오므로, 프로그램이 실행 중인 [[Runtime]]에서야 모든 코드가 JVM과 연결됨.
	- 이렇게 동적으로 클래스를 로딩/[[Linking(java)|링킹(java)]]해주는 역할을 하는 것이 바로 클래스 로더.
	- 바이트 코드([[Class File(java)|.class]]) 파일을 묶어서 JVM이 OS로부터 할당 받은 메모리 영역인 [[Runtime Data Area(Java)]]로 적재함.


# 클래스 로더의 종류와 구성
- 클래스 로더들은 계층적으로 구성되어 있으며, 아래에 설명한 순서대로 로딩을 시도한다.
	- 클래스 로딩은 요청 시 동적으로 이루어지며, 클래스가 처음으로 참조될 때 해당 클래스 로더에 의해 수행된다.
	- 이러한 클래스 로더의 계층 구조는 클래스의 가시성 및 범위 등을 관리하며, 각 클래스 로더가 특정한 역할을 담당하도록 구성되어 있다.
- 클래스 로더는 아래 세 종류로 이루어져 있다.

 ## 부트스트랩 클래스 로더
- JVM의 최상위 클래스 로더로, <JAVA_HOME>/jre/lib 디렉토리에 위치한 핵심 자바 라이브러리들을 불러들이는 역할을 수행.
- 주로 rt.jar 파일에 포함된 시스템 라이브러리 등을 로드함.
- [[네이티브 코드]]로 작성되어 있으며, Java로 구현된 클래스로더로 로드할 수 없음.


 ## 확장 클래스 로더
- 부트스트랩 클래스 로더 다음에 위치하며, Java 확장 기능에 필요한 클래스들을 로드함.
- 확장 디렉토리(<JAVA_HOME>/jre/lib/ext 또는 java.ext.dirs 시스템 속성에 지정된 기타 디렉토리)에 코드를 로드한다.
- 보통 Standard Extension Mechanism을 사용하여 확장을 로드함.

 ## 시스템 클래스 로더(=애플리케이션 클래스 로더)
- 사용자가 작성한 클래스와 애플리케이션에서 사용되는 클래스들을 로드함.
- 클래스패스에 지정된 디렉토리 및 JAR 파일들을 검색하여 클래스를 로드함.
- 대부분의 자바 애플리케이션에서 사용되는 클래스들은 이 클래스 로더를 통해 로드됨.


# 클래스 로더가 지켜야 할 세 가지 원칙
[출처](https://leeyh0216.github.io/posts/java_class_loader/)
## Delegation Principle
- 위임 원칙은 클래스 로딩이 필요한 경우 부모 클래스로더 방향으로 클래스 로딩을 위임하는 것.
- 새로운 클래스를 로드해야 할 때, 다음과 같은 방식으로 클래스 로드를 수행한다.
	1. JVM의 Method Area에 클래스가 로드되어 있는지 확인한다. 
		1. 만일 로드 되어 있는 경우 해당 클래스를 사용한다.
	2. Method Area에 클래스가 로드되어 있지 않은 경우, 애플리케이션 클래스 로더에 클래스 로드를 요청한다.
	3. 애플리케이션 클래스로더는 확장 클래스로더에 클래스 로드를 요청한다.
	4. 확장 클래스로더는 부트스트랩 클래스로더에 클래스 로드를 요청한다.
	5. 부트스트랩 클래스로더는 부트스트랩 Classpath(JDK/JRE/LIB)에 해당 클래스가 있는지 확인한다.
		1. 클래스가 존재하지 않는 경우, 확장 클래스 로더가 요청을 수행하도록 한다.
	6. 확장 클래스 로더는 확장 Classpath(JDK/JRE/LIB/EXT)에 해당 클래스가 있는지 확인한다. 
		1. 클래스가 존재하지 않는 경우, 애플리케이션 클래스 로더가 요청을 수행하도록 한다.
	7. 애플리케이션 클래스로더는 애플리케이션 Classpath에 해당 클래스가 있는지 확인한다.
		1. 클래스가 존재하지 않는 경우 [[ClassNotFoundException]] 을 발생시킨다.

## Visibility Principle
- 가시 범위 원칙은 **하위 클래스로더는 상위 클래스로더가 로드한 클래스를 볼 수 있지만, 반대로 상위 클래스로더는 하위 클래스로더가 로드한 클래스를 알 수 없다는 것**이다. 
	- 때문에 java.lang.Object 클래스 등 상위 클래스로더에서 로드한 클래스도 하위 클래스로더인 애플리케이션 클래스로더 등에서 사용할 수 있는 것이다.
	- 이러한 원칙이 없는 경우 클래스로더 간의 상/하위 개념이 사라지기 때문에 이 원칙을 반드시 지켜야 한다.

## Uniqueness Principle
- 유일성 원칙은 **하위 클래스로더가 상위 클래스로더에서 로드한 클래스를 다시 로드하지 않아야 한다**는 원칙이다. 
	- 이 원칙이 지켜지지 않는다면 JVM에 동일한 클래스가 2개 이상 로드되는 상황이 발생할 수 있다. 

# 심화 내용 링크
[클래스 로더와 커스텀 클래스 로더 만들기](https://leeyh0216.github.io/posts/java_class_loader/)