---
tags:
  - linking
  - static
aliases:
  - 정적 링킹
  - Static Linking
  - 컴파일 링킹
  - Compile-Time Linking
---
# Static Linking(=Compile-Time Linking)
- 컴파일 타임 링킹 혹은 정적 링킹은 [[Compile]]시 정적으로 일어나는 [[Linking]]을 말한다.
	- 컴파일 타임 링킹이라는 명칭은 [[Linking]]이 컴파일 타임에 이루어진다는 것을 강조하는 관점이고
	- 정적 링킹이라는 명칭은 링킹된 결과물이 정적으로 Linking time에 확정된다는 특성을 강조하는 관점이다.
- 정적 링킹은 [[Compile|컴파일]] 과정에서 이루어진다. 
	- 즉, [[Compiler]]가 [[Source Code]] 파일들을 [[Compile]]하여 [[Object Code|오브젝트 코드]]로 만든 후, 이 오브젝트 코드를 결합하는 단계에서 이루어진다.
	- 작성된 소스 코드가 사용하는 OS API([[System call]]) 또는 표준 라이브러리를 연결시켜서 exe 파일로 만든다. 
		- 여기서 실행 파일(.exe)는 타겟 파일(target file)이라고도 한다. 
	- ![[C언어의 컴파일 과정.png]]
	- 원시코드 ~ 목적파일까지의 과정을 [[Compiling]], 목적파일~ 타겟파일까지를 'Linking'으로 부른다. 
		- Compiling 구간만을 컴파일로 보는 관점을 '좁은 의미의 컴파일'이라고 하고, Compiling + Linking 전 과정을 컴파일로 보는 관점을 '넓은 의미의 컴파일'이라고 한다. 

## 정적 링킹의 장단점
- 정적 링킹으로 구성된 파일은 실행 파일(.exe)안에 모든 내용이 다 들어있다.
	- 장점
		- 그래서 별도의 라이브러리가 필요 없다. 
		- 또 실행 속도가 빠르다. 
		- 정적 링킹 프로그램에서 모든 코드는 하나의 실행 모듈에 담기기 때문에 compatibility issues 즉, 불일치에 대한 걱정을 하지 않아도 된다. 
	- 단점 
		- 라이브러리가 실행 파일에 통합되어 있다는 말은, 실행 파일이 다르면 라이브러리를 통해 같은 기능을 사용할 지라도, 같은 코드를 실행파일마다 각각 메모리에 로딩해야 한다는 것이다.
			- 때문에 같은 기능의 같은 코드를 메모리에 중복해서 로딩해야 한다는 단점이 생긴다.
				- 예시) 하나의 리눅스 서버에 수 십명의 유저가 정적 링킹으로 만들어진 실행 파일을 실행시키면, 중복된 라이브러이들, 즉 똑같은 코드가 메모리에 50번 올라가게 된다. 
			- 이는 심각한 메모리 낭비를 야기한다.
		- 또, A라는 함수에 변화가 생길 경우, 그 변화를 적용하기 위해서 다시 컴파일하여 다시 링킹을 해야 한다.
			- 실행 가능한 목적 파일을 만들 때, 해당 함수 정보를 그냥 복사해왔기 때문에 코드에 변화가 일어나도 다시 컴파일하지 않는 이상 변화가 적용되지 않는다.
	- 정적 링킹의 이러한 단점을 보완하기 위해 [[Dynamic Linking|동적 링킹]]이 고안되었다.


## 레퍼런스
- [컴파일과 링킹, 런타임, 로딩](https://charles098.tistory.com/102)
- [정적 링킹과 동적 링킹](https://live-everyday.tistory.com/69?category=835430)