---
tags:
---
---
- 옵티마이저는 사용자의 쿼리를 최적으로 처리될 수 있게 하는 쿼리의 실행 계획을 수립할 수 있어야 한다.
	- 하지만 옵티마이저가 관리자나 사용자의 개입 없이 항상 좋은 실행 계획을 만들어낼 수 있는 것은 아니다. 
		- DBMS 서버는 이러한 문제점을 관리자나 사용자가 보완할 수 있도록 **EXPLAIN 명령**으로 옵티마이저가 수립한 실행 계획을 확인할 수 있게 해준다.
	- MySQL 서버에서 보여주는 실행 계획을 읽고 이해하려면 MySQL 서버가 데이터를 처리하는 로직을 이해할 필요가 있다. 
		- 이 챕터에서는 그 실행 계획을 해석하기 위해, 실행 계획을 구성하는 요소들을 다룬다.
			- 통계 정보 : MySQL 서버의 실행 계획에 가장 큰 영향을 미치는 요소
			- 실행 계획 읽는 순서
			- 실행 계획에 출력되는 키워드
			- 알고리즘 등

# 10.1 통계 정보
- MySQL 서버는 **5.7 버전까지** 테이블과 인덱스에 대한 **개괄적인 정보**를 가지고 실행 계획을 수립함.
	- 하지만 테이블 칼럼 값들이 실제 어떻게 분포돼 있는지에 대한 정보가 없어서 실행 계획의 정확도가 떨어짐.
- **MySQL 8.0 버전부터** 인덱스 되지 않은 칼럼들에 대해서도 데이터 분포도를 수집해서 저장하는 히스토그램(Histogram) 정보가 도입됐자. 
	- 히스토그램이 도입됐다고 해서 기존의 테이블이나 인덱스의 통계 정보가 필요치 않은 것은 아님. 
	- 이하의 내용에서는 테이블 및 인덱스에 대한 통계 정보와 히스토그램을 나누어 살펴봄.

## 10.1.1 테이블 및 인덱스 통계 정보
- [[9. 옵티마이저와 힌트|비용 기반 최적화]]에서 가장 중요한 것은 통계 정보
	- 통계 정보가 정확하지 않다면 전혀 엉뚱한 방향으로 쿼리를 실행할 수 있기 때문. 
		- 예를 들어, 1억 건의 레코드가 저장된 테이블의 통계 정보가 갱신 되지 않아서 레코드가 10건 미만인 것처럼 돼 있다면, 옵티마이저는 실제 쿼리를 실행할 때 인덱스 레인지 스캔이 아니라 테이블을 처음부터 끝까지 읽는 풀 테이블 스캔 방식으로 실행해버릴 수 있다. 
			- 부정확한 통계 정보는 0.1초만에 끝날 쿼리를 1시간이 소요되는 방식으로 실행시킬 수도 잇다.
- MySQL 또한 다른 DBMS와 같이 비용 기반의 최적화를 사용하지만, 다른 DBMS보다 **통계 정보의 정확도가 높지 않고**, **통계 정보의 휘발성**이 강했다.
	- 그래서 MySQL 서버에서는 쿼리의 실행 계획을 수립할 때 실제 테이블의 데이터를 일부 분석해서 통계 정보를 보완해서 사용했다.
		- 이러한 이유로 MySQL 5.6 버전부터는 통계 정보의 정확성을 높일 수 있는 방법이 제공되기 시작했지만, 아직도 많은 사용자가 기본 방식을 그대로 사용한다.
		- 이하의 내용에서는 MySQL 8.0 버전에서 통계 정보 관리가 어떻게 개선됐는지도 함께 살펴보겠다. 
### 10.1.1.1  MySQL 서버의 통계 정보
- MySQL 5.6 버전부터는 InnoDB 스토리지 엔진을 사용하는 테이블에 대한 통계 정보를 영구적으로(Persistent) 관리할 수 있게 개선됐다. 
	- **MySQL 5.5 버전까지는** 각 테이블의 통계 정보가 메모리에만 관리되고, SHOW INDEX 명령으로만 테이블의 인덱스 칼럼의 분포도를 볼 수 있었다. 
		- 이처럼 통계 정보가 메모리에 관리될 경우 MySQL 서버가 재시작 되면 지금까지 수집 된 통계 정보가 모두 사라진다. 
	- **MySQL 5.6 버전부터는** 각 테이블의 통계 정보를 mysql 데이터베이스의 innodb_index_stats 테이블과 innodb_table_stats 테이블로 관리할 수 있게 개선됐다. 
		- 이렇게 통계 정보를 테이블로 관리함으로써 MySQL 서버가 재시작되도 기존의 통계 정보를 유지할 수 있게 됐다. 
	- MySQL 5.6에서 테이블을 생성할 때는 STATS_PERSISTENT 옵션을 설정할 수 있는데, 이 설정 값에 따라 테이블 단위로 영구적인 통계 정보를 보관할지 말 지를 결정할 수 있다. 
```
mysql> CREATE TABLE tab_test (fs1 INT, fd2 VARCHAR(20), PRIMARY KEY(fd1))
		ENGINE=InnoDB
		STATS_PERSISTENT={ DEFAULT | 0 | 1}
```
- 테이블 생성 시 STATS_PERSISTENT 옵션을 통해 통계 정보의 영구 저장을 설정할 수 있다.
	- 0 : 영구 저장하지 않음
	- 1 : 영구 저장함
	- DEFAULT : innodb_stats_poersistent 변수로 결정된다.
		- 기본 값은 1이다.
	- ALTER 명령으로 테이블의 저장 설정을 변경할 수 있다.
- 통계 테이블이 저장하고 있는 정보들
	- innodb_index_stats.stat_name='n_diff_pfx%' : 인덱스가 가진 유니크 한 값의 개수
	- innodb_index_stats.stat_name='n_leaf_pages' : 인덱스의 리프 노드 페이지 개수
	- innodb_index_stats.stat_name='size' : 인덱스 트리의 전체 페이지 개수
	- innodb_index_stats.n_rows : 테이블의 전체 레코드 건수
	- innodb_index_stats.clustered_index_size : 프라이머리 키의 크기(InnoDB 페이지 개수)
	- innodb_table_stats.sub_of_other_index_sizes : 프라이머리 키를 제외한 인덱스의 크기(InnoDB 페이지 개수)
> [!note] innodb_table_stats.sum_of_other_index_sizes 칼럼의 값은 테이블의 STATS_AUTO_RECALC 옵션에 따라 0으로 보일 수도 있는데, 그 경우 다음과 같이 테이블에 대해 ANALYZE TABLE 명령을 실행하면 통곗값이 저장된다.

- MySQL 5.5 버전까지 통계 정보 관리(InMemory)에 대한 추가 사항들
	- MySQL 서버가 재시작 되면 통계 정보가 초기화되어 모든 테이블의 통계 정보를 다시 수집해야 했음.
	- 그리고 사용자나 관리자가 알지 못하는 순간에 다음과 같은 이벤트가 발생하면 자동으로 통계 정보가 갱신 됨.
		- 테이블이 새로 오픈 되는 경우
		- 테이블의 레코드가 대량으로 변경되는 경우(테이블의 전체 레코드 중에서 1/16 정도의 UPDATE 또는 INSERT나 DELETE가 실행되는 경우)
		- ANALYZE TABLE 명령이 실행되는 경우
		- SHOW TABLE STATUS 명령이나 SHOW INDEX FROM 명령이 실행되는 경우
		- InnoDB 모니터가 활성화되는 경우
		- innodb_stats_on_metadata 시스템 설정인 ON인 상태에서 SHOW TABLE STATUS 명령이 실행되는 경우
	- 이렇게 자주 테이블의 통계 정보가 갱신 되면 응용 프로그램의 쿼리를 효율적으로 처리하지 못하는 경우가 발생할 수 있었다. 
		- innodb_stats_auto_recalc 시스템 설정 변수의 값을 OFF로 설정해서 통계 정보가 자동으로 갱신 되는 것을 막을 수 있다 .
			- DEFAULT 값은 ON이므로 영구적인 통계 정보를 이용하고자 한다면 이 설정을 OFF로 변경.
			- 통계 정보를 자동으로 수집할지 여부도 테이블을 생성할 때 STATS_AUTO_RECALC 옵션을 이용해 테이블 단위로 조정할 수 있다. 
				- STATS_AUTO_RECALC=1: 테이블의 통계 정보를 MySQL 5.5 이전의 방식대로 자동 수집.
				- STATS_AUTO_RECALC=0 : 테이블의 통계 정보는 ANALYZE TABLE 명령을 실행할 때만 수집된다. 
				- STATS_AUTO_RECALC=DEFAULT : 테이블을 생성할 때 별도로 STATS_AUTO_RECALC 옵션을 설정하지 않은 것과 동일, 테이블의 통계 정보 수집을 innodb_stats_auto_recalc 시스템 설정 변수의 값으로 결정
		- MySQL 5.6 이상에서 영구적인 통계 정보가 도입되면서 이렇게 의도하지 않은 통계 정보 변경을 막을 수 있게 됐다. 
- MySQL 5.5 버전에서는 테이블의 통계 정보를 수집할 때 몇 개의 InnoDB 테이블 블록을 샘플링할지 결정하는 옵션으로 innodb_stats_sample_pages 시스템 설정 변수가 제공 되는데, 이 옵션은 MySQL 5.6 버전부터 **Deprecated** 되었다. 
	- 대신 이 시스템 변수가 아래와 같이 분리됨.
		-  innodb_stats_transient_sample_pages :  자동으로 통계 정보 수집이 실행될 때 설정된 값(기본값 : 8)개 페이지만 임의로 샘플링해서 분석하고 그 결과를 통계 정보로 활용함.
		- innodb_stats_persistent_sample_pages : 기본 값은 20이며, ANALYZE TABLE 명령이 실행되면 임의로 설정값 개수(기본값 : 20) 페이지만 샘플링해서 분석하고 그 결과를 영구적인 통계 정보 테이블에 저장하고 활용함. 
- 영구적인 통계 정보를 사용한다면 MySQL 서버의 점검이나 사용량이 많지 않은 시간을 이용해 더 정확한 통계 정보를 수집할 수도 있다. 
	- 물론 더 정확한 통계 정보 수집에는 많은 시간이 소요되겠지만, 이 통계 정보의 정확성에 의해 쿼리의 성능이 결정되기 때문에 시간을 투자할 충분한 가치가 있다. 
		- 더 정확한 통계 정보를 수집하고자 한다면 innodb_stats_persistent_sample_pages 시스템 변수에 높은 값을 할당하면 된다. 
		- 다만 너무 높이면 통계 정보 수집 시간이 길어지므로 주의해야 한다. 
## 10.1.2 히스토그램
- MySQL 5.7 버전까지의 통계 정보
	- 단순히 [[선택도와 기수성|인덱스된 칼럼의 유니크한 값의 개수]] 정도만 가지고 있었음.
		- 옵티마이저가 최적의 실행 계획을 수립하기에는 많이 부족함.
		- 그래서 옵티마이저는 이러한 부족함을 메우기 위해 실행 계획 수립할 때 실제 인덱스의 일부 페이지를 랜덤으로 가져와 참조하는 방식 사용.
	- MySQL 8.0 버전으로 업그레이드 되면서 MySQL 서버도 드디어 칼럼의 데이터 분포도를 참조할 수 있는 [[히스토그램(Histogram)]] 정보를 활용할 수 있게 됐다.

### 10.1.2.1 히스토그램 정보 수집 및 삭제
- MySQL 8.0 버전에서는 히스토그램 정보는 칼럼 단위로 관리되는데, 수동으로 수집 및 관리해야 한다.
	- `ANALYZE TABLE ... UPDATE HISTOGRAM` 명령을 실행해 관리한다.
	- 수집된 히스토그램 정보는 [[시스템 딕셔너리]]에 함께 저장되고, MySQL 서버가 시작될 때 딕셔너리의 히스토그램 정보를 inforamtion_schema 데이터베이스의 coulmn_statistics 테이블로 로드한다.
	- 그래서 실제 히스토그램 정보를 조회하려면 column_statistics 테이블을 SELECT 해서 참조할 수 있다.
	- 실제 히스토그램 수집 및 조회 예제 
```
-- 테이블 생성
mysql> CREATE TABLE employees (
    emp_no      INT             NOT NULL,
    birth_date  DATE            NOT NULL,
    first_name  VARCHAR(14)     NOT NULL,
    last_name   VARCHAR(16)     NOT NULL,
    gender      ENUM ('M','F')  NOT NULL,    
    hire_date   DATE            NOT NULL,
    PRIMARY KEY (emp_no),
    KEY idx_first_name (first_name))
    ;


-- 데이터 로드
mysql> source load_employees.dump;


-- 히스토그램 수집
mysql> ANALYZE TABLE employees
UPDATE HISTOGRAM ON gender,hire_date;
+-------------------+-----------+----------+------------------------------------------------------+
| Table             | Op        | Msg_type | Msg_text                                             |
+-------------------+-----------+----------+------------------------------------------------------+
| test_db.employees | histogram | status   | Histogram statistics created for column 'gender'.    |
| test_db.employees | histogram | status   | Histogram statistics created for column 'hire_date'. |
+-------------------+-----------+----------+------------------------------------------------------+


-- COLUMN_STATISTICS 조회
mysql> select *
from information_schema.COLUMN_STATISTICS
where table_name='employees'\G

*************************** 1. row ***************************
SCHEMA_NAME: test_db
 TABLE_NAME: employees
COLUMN_NAME: gender
  HISTOGRAM: {"buckets": [[1, 0.5998776829658968]
, [2, 1.0]], "data-type": "enum", "null-values": 0.0, "collation-id": 45,
 "last-updated": "2021-11-21 12:06:45.393325", 
 "sampling-rate": 0.34783905681630983, "histogram-type": "singleton",
  "number-of-buckets-specified": 100}
*************************** 2. row ***************************
SCHEMA_NAME: test_db
 TABLE_NAME: employees
COLUMN_NAME: hire_date
  HISTOGRAM: {"buckets": [["1985-01-01", "1985-02-27", 0.010096009164069856, 29]
, ["1985-02-28", "1985-03-25", 0.01992020269679937, 26]
, ["1985-03-26", "1985-04-23", 0.02990942714855695, 29]
, ["1985-04-24", "1985-05-20", 0.03984040539359874, 27]
, ["1985-05-21", "1985-06-16", 0.04983933754647562, 27]
, ["1985-06-17", "1985-07-15", 0.06011008533069284, 29]
, ["1985-07-16", "1985-08-10", 0.06989544805894517, 26]
, ["1985-08-11", "1985-09-07", 0.07998174952189573, 28]
, ["1985-09-08", "1985-10-05", 0.08999038937589189, 28]
, ["1985-10-06", "1985-11-03", 0.09993107532205299, 29]
, ["1985-11-04", "1985-12-02", 0.10988146896933337, 29]
, ["1985-12-03", "1986-01-01", 0.12004543204123831, 30]
, ["1986-01-02", "1986-01-30", 0.13013173350418888, 29]
, ["1986-01-31", "1986-03-01", 0.14002388094475346, 30]
, ["1986-03-02", "1986-04-01", 0.15010047470658475, 31]
, ["1986-04-02", "1986-05-01", 0.16002174525050722, 30]
, ["1986-05-02", "1986-05-31", 0.16993330809331042, 30]
, ["1986-06-01", "1986-07-01", 0.18005844036073818, 31]
, ["1986-07-02", "1986-08-01", 0.19014474182368873, 31]
, ["1986-08-02", "1986-09-01", 0.19995922765529894, 31]
, ["1986-09-02", "1986-10-02", 0.2100843599227267, 31]
, ["1986-10-03", "1986-11-02", 0.219869722650979, 31]
, ["1986-11-03", "1986-12-03", 0.23006280882624186, 31]
, ["1986-12-04", "1987-01-02", 0.24001320247352226, 30]
, ["1987-01-03", "1987-02-04", 0.2500315500286377, 33]
, ["1987-02-05", "1987-03-07", 0.2600207744803953, 31]
, ["1987-03-08", "1987-04-07", 0.2698546757142441, 31]
, ["1987-04-08", "1987-05-09", 0.2799215617749561, 32]
, ["1987-05-10", "1987-06-11", 0.2899690324334294, 33]
, ["1987-06-12", "1987-07-14", 0.3000067953907835, 33]
, ["1987-07-15", "1987-08-17", 0.3100154352447797, 34]
, ["1987-08-18", "1987-09-18", 0.3198784595819864, 32]
, ["1987-09-19", "1987-10-22", 0.32986768403374395, 34]
, ["1987-10-23", "1987-11-23", 0.3400898933123647, 32]
, ["1987-11-24", "1987-12-26", 0.35013736397083806, 33]
, ["1987-12-27", "1988-01-28", 0.36002951141140266, 33]
, ["1988-01-29", "1988-03-01", 0.36995078195532516, 33]
, ["1988-03-02", "1988-04-06", 0.3800856219238722, 36]
, ["1988-04-07", "1988-05-10", 0.3900748463756298, 34]
, ["1988-05-11", "1988-06-14", 0.40013202473522247, 35]
, ["1988-06-15", "1988-07-20", 0.4099659259690713, 36]
, ["1988-07-21", "1988-08-23", 0.4198483657085166, 34]
, ["1988-08-24", "1988-09-29", 0.4300026210793022, 37]
, ["1988-09-30", "1988-11-04", 0.4400792148411335, 36]
, ["1988-11-05", "1988-12-09", 0.4498645775693858, 35]
, ["1988-12-10", "1989-01-14", 0.460135325353603, 36]
, ["1989-01-15", "1989-02-20", 0.470008057391929, 37]
, ["1989-02-21", "1989-03-29", 0.4799584510392094, 37]
, ["1989-03-30", "1989-05-08", 0.49006416790439855, 40]
, ["1989-05-09", "1989-06-15", 0.5000339769539175, 38]
, ["1989-06-16", "1989-07-22", 0.509887293590005, 37]
, ["1989-07-23", "1989-08-29", 0.5199638873518362, 38]
, ["1989-08-30", "1989-10-09", 0.5300404811136675, 41]
, ["1989-10-10", "1989-11-16", 0.5399326285542321, 38]
, ["1989-11-17", "1989-12-27", 0.5500771762238984, 41]
, ["1989-12-28", "1990-02-05", 0.5600761083767754, 40]
, ["1990-02-06", "1990-03-19", 0.5700167943229364, 42]
, ["1990-03-20", "1990-04-30", 0.5800933880847676, 42]
, ["1990-05-01", "1990-06-13", 0.5899661201230937, 44]
, ["1990-06-14", "1990-07-26", 0.6000912523905214, 43]
, ["1990-07-27", "1990-09-07", 0.6100610614400404, 43]
, ["1990-09-08", "1990-10-21", 0.6200017473862015, 44]
, ["1990-10-22", "1990-12-03", 0.629923017930124, 43]
, ["1990-12-04", "1991-01-16", 0.6399316577841201, 44]
, ["1991-01-17", "1991-03-03", 0.6500859131549058, 46]
, ["1991-03-04", "1991-04-18", 0.6600848453077827, 46]
, ["1991-04-19", "1991-06-05", 0.670035238955063, 48]
, ["1991-06-06", "1991-07-23", 0.6799759249012242, 48]
, ["1991-07-24", "1991-09-07", 0.6899360262496238, 46]
, ["1991-09-08", "1991-10-30", 0.7000029123103357, 53]
, ["1991-10-31", "1991-12-19", 0.7100503829688092, 50]
, ["1991-12-20", "1992-02-08", 0.7200298997194474, 51]
, ["1992-02-09", "1992-03-30", 0.7299608779644893, 51]
, ["1992-03-31", "1992-05-22", 0.7399209793128889, 53]
, ["1992-05-23", "1992-07-16", 0.7499004960635272, 55]
, ["1992-07-17", "1992-09-10", 0.7599382590208813, 56]
, ["1992-09-11", "1992-11-03", 0.7699274834726388, 54]
, ["1992-11-04", "1993-01-02", 0.7799264156255157, 60]
, ["1993-01-03", "1993-02-26", 0.7900612555940628, 55]
, ["1993-02-27", "1993-04-26", 0.8000116492413432, 59]
, ["1993-04-27", "1993-06-29", 0.81001058139422, 64]
, ["1993-06-30", "1993-09-02", 0.819980390443739, 65]
, ["1993-09-03", "1993-11-09", 0.8299793225966159, 68]
, ["1993-11-10", "1994-01-15", 0.8399491316461348, 67]
, ["1994-01-16", "1994-03-30", 0.8498995252934153, 74]
, ["1994-03-31", "1994-06-11", 0.8599955344574851, 73]
, ["1994-06-12", "1994-08-28", 0.8700041743114812, 78]
, ["1994-08-29", "1994-11-15", 0.8799351525565231, 79]
, ["1994-11-16", "1995-02-05", 0.8900117463183543, 82]
, ["1995-02-06", "1995-05-04", 0.9000495092757084, 88]
, ["1995-05-05", "1995-07-29", 0.9099610721185116, 86]
, ["1995-07-30", "1995-11-03", 0.9200279581792236, 97]
, ["1995-11-04", "1996-02-08", 0.9300365980332198, 97]
, ["1996-02-09", "1996-05-31", 0.9400064070827387, 113]
, ["1996-06-01", "1996-09-21", 0.9500053392356156, 113]
, ["1996-09-22", "1997-01-27", 0.9600042713884925, 128]
, ["1997-01-28", "1997-06-24", 0.9700129112424887, 148]
, ["1997-06-25", "1997-12-13", 0.9799924279931269, 171]
, ["1997-12-14", "1998-07-27", 0.9899816524448846, 224]
, ["1998-07-28", "2000-01-28", 1.0, 450]], 
"data-type": "date", "null-values": 0.0, 
"collation-id": 8, "last-updated": "2021-11-21 12:06:45.393773", 
"sampling-rate": 0.34783905681630983, "histogram-type": "equi-height", 
"number-of-buckets-specified": 100}
```
- MySQL 8.0 버전에서는 다음과 같이 2종류의 히스토그램 타입이 지원된다.
	- **Singleton(싱글톤 히스토그램)** : 칼럼값 개별로 레코드 건수를 관리하는 히스토그램.
		- Value-Based 히스토그램 또는 도수 분포라고도 불린다.
		- 특정 값에 대한 빈도가 1인 경우를 나타냄.
		- 데이터 세트에서 대부분의 값들이 한 번만 발생하고 나머지 값들은 발생하지 않거나 매우 드물게 발생할 때 해당됩니다.
		- 일반적으로 데이터 세트가 특정 값들에 대해 특이하게 나타나는 경우에 싱글톤 히스토그램이 생성됩니다.
	- **Equi-Height(높이 균형 히스토그램)** : 칼럼 값이 범위를 균등한 개수로 구분해서 관리하는 히스토그램으로, Height-Balanced 히스토그램이라고도 불린다.
		- 높이 균형 히스토그램은 히스토그램의 막대들이 비슷한 높이를 가지고 있는 경우를 나타냅니다.
		- 데이터의 분포가 균일하게 퍼져있어 각 구간의 빈도가 비슷하게 나타난 경우 해당됩니다.
		- 높이 균형 히스토그램은 데이터의 다양한 범위에서 비슷한 양의 빈도를 갖는 경우에 해당하며, 히스토그램이 균형 있게 나타나면 데이터의 분포를 이해하는 데 도움이 될 수 있습니다.
	- 히스토그램은 버킷(Bucket) 단위로 구분되어 레코드 건수나 칼럼값의 범위가 관리된다.
		- 싱글톤 히스토그램은 칼럼이 가지는 값별로 버킷이 할당.
			- 각 버킷이 `칼럼의 값`과 `발생 빈도의 비율`의 2개 값을 가진다.
		- 높이 균형 히스토그램에서는 개수가 균등한 칼럼값의 범위별로 하나의 버킷이 할당된다. 
			- 각 버킷이 `범위 시작 값`과 `마지막 값`, 그리고 `발생 빈도율`과 `각 버킷에 포함된 유니크한 값의 개수` 등 4개의 값을 가진다. 
	- 각 히스토그램 형태에 대한 예시
	- ![[히스토그램(싱글톤, 높이 균형)의 예시.png]]
- 상기 그림 설명
	- 그림 10.1
		- ENUM('M', 'F') 타입인 gender 칼럼이 가질 수 있는 2개의 값에 대한 누적된 레코드 건수의 비율을 가지고 있음.
			- 이처럼 싱글톤 히스토그램은 주로 코드 값과 같이 유니크한 값의 개수가 상대적으로 적은(히스토그램 버킷 수보다 적은) 경우 사용된다. 
			- 히스토그램의 모든 레코드 건수 비율은 **누적**으로 표시된다. 그래서 gender 칼럼의 값이 'F' 인 레코드 그래프가 1로 표시되고, 그 실 비율은 1-0.5998이 된다.
	- 그림 10.2
		- 칼럼 값의 각 범위에 대해 레코드 건수 비율이 누적으로 표시된다.
		- 그래서 히스토그램의 버킷 범위가 뒤로 갈 수록 비율이 높아지는 것으로 보이지만, 사실은 범위별로 비율이 같은 수준에서 hire_date 칼럼의 범위가 선택된 것이다. 
			- 그래프의 기울기가 일정한 것을 보면 각 범위가 비슷한 값(레코드의 건수)를 가진다는 것을 알 수 있다. 
- information_schema.column_statistics 테이블의 HISTOGRAM 칼럼이 가진 나머지 필드들
	- sampling-rate : 히스토그램 정보를 수집하기 위해 스캔한 페이지의 비율
		- 샘플링 비율이 0.35라면 전체 데이터 페이지의 35%를 스캔해서 이 정보가 수집됐다는 것을 의미.
			- 물론 샘플링 비율이 높아질 수록 더 정확한 히스토그램이 되나, 풀 스캔은 부하가 높으며 시스템 자원을 많이 소모한다. 
			- MySQL 서버는 `histogram_generation_max_mem_size 시스템 변수`에 설정된 메모리 크기에 맞게 적절히 샘플링한다.
			- 기본 값은 20MB로 초기화 되어 있다.
	- histogram-type : 히스토그램의 종류
	- number-of-buckets-spectified : 히스토그램을 생성할 때 설정했던 버킷의 개수를 저장.
		- 히스토그램을 생성할 때 별도로 버킷의 개수를 지정하지 않았다면 기본으로 100개의 버킷이 사용된다.
		- 버킷은 최대 1024개를 설정할 수 있지만, 일반적으로 100개의 버킷이면 충분한 것으로 알려져 있다.
> [!warning] MySQL 8.0.19 미만의 버전까지는 히스토그램 생성 시 샘플링 비율(Sampling-rate)과 histogram_generation_max_mem_size 시스템 변수의 크기에 관계없이 MySQL 서버는 풀 스캔을 통해 데이터 페이지를 샘플링해서 히스토그램을 생성했다. 하지만 MySQL 8.0.19 버전부터 InnoDB 스토리지 엔진 자체적으로 샘플링 알고리즘을 구현했으며, 더이상 히스토그램 수집 시 풀 테이블 스캔이 필요하지 않게 됐다. 지금 사용 중인 버전이 MySQL 8.0.19 미만의 버전이라면 히스토그램 수집 시 주의할 것.

- 생성된 히스토그램의 삭제
	- 코드 예시 : ANALYZE TABLE db.table DROP HISTOGRAM on cal1, cal2;
	- 히스토그램의 삭제 작업은 테이블의 데이터를 참조하는 것이 아니라 딕셔너리의 내용만 삭제하기 때문에 다른 쿼리 처리의 성능에 영향을 주지 않고 즉시 완료된다.
		- 하지만 히스토그램이 사라지면 쿼리의 실행 계획이 달라질 수 있으므로 주의.
	- 히스토그램을 삭제하지 않고 MySQL 옵티마이저가 히스토그램을 사용하지 않게 하려면 다음과 같이 `optimizer_switch 시스템 변수`의 값을 변경하면 된다. 
		- 코드 예시 : SET GLOBAL optimizer_switch='condition_fanout_filter=off';
			- 글로벌로 변경하면 MySQL 서버의 모든 쿼리가 히스토그램을 사용하지 않는다.
			- 또한 condition_fanout_filter 옵션에 의해 영향받는 다른 최적화 기능이 사용되지 않을 수 있으니 주의.
		- 특정 커넥션 또는 특정 쿼리에서만 히스토그램을 사용하지 않고자 한다면 다음과 같은 방법을 사용.
			- 현재 커넥션에서 실행되는 쿼리만 히스토그램을 사용하지 않게 설정
				- SET SESSION optimizer_switch='confition_fanout_filter=off';
			- 현재 쿼리만 히스토그램을 사용하지 않게 설정
				- SELECT /*+ SET_VAR(optimizer_switch='condition_fanout_filter=off') */* From...

---

### 10.1.2.2 히스토그램의 용도
- MySQL 서버에 히스토그램이 도입되기 이전에도 테이블과 인덱스에 대한 통계 정보는 존재.
	- 하지만 기존 MySQL 서버가 가지고 있던 통계 정보는 테이블의 전체 레코드 건수, 인덱스된 칼럼이 가지는 유니크한 값의 개수 정도.
		- 예를 들어, 테이블의 레코드가 1000건, 어떤 칼럼의 유니크한 값의 개수(카디널리티)가 100개였다면 MySQL 서버는 이 칼럼에 대해 다음의 동등 비교 검색을 하면 대략 10개의 레코드가 일치할 것이라고 예측
			- mysql> SELECT * FROM order WHERE user_id='matt.lee';
		- 하지만 실제 응용 프로그램의 데이터는 항상 균등한 분포도를 가지지 않는다. 
			- 어떤 사용자는 주문 레코드를 많이 가지고 있고, 또 다른 사용자는 주문 정보가 하나도 없을 수도.
	- 이러한 단점을 보완하기 위해서 히스토그램이 도입됐다.
- 히스토그램은 특정 칼럼이 가지는 모든 값에 대한 분포도 정보를 가지지는 않지만 각 범위(버킷) 별로 레코드의 건수와 유니크한 값의 개수 정보를 가지기 때문에 훨씬 정확한 예측을 할 수 있다.
- 히스토그램이 있는 경우와 없는 경우에 대한 예측치 차이 예시(Real MySQL 1권 404p~405p) 생략
	- 히스토그램 정보가 없으면 옵티마이저는 데이터가 균등하게 분포돼 있을 것으로 예측한다.
	- 하지만 히스토그램이 있으면 특정 범위의 데이터가 많고 적음을 식별할 수 있다. 
		- 이는 쿼리의 성능에 상당한 영향을 미친다.
	- 히스토그램으로 인해 조인 순서에 차이가 생기는 경우를 상정한 예시(책 406p)
		- 인덱스 되지 않은 칼럼인 경우, 히스토그램이 없다면 옵티마이저는 해당 칼럼들의 데이터 분포를 전혀 알지 못하고 실행 계획을 수립한다.
		- 때문에 옵티마이저는 테이블의 전체 레코드 건수나 크기 등의 단순한 정보만으로 조인의 드라이빙 테이블을 결정하게 된다.
			- 이러한 차이로 쿼리의 성능은 10배 정도의 차이를 보일 수 있으며, InnoDB 버퍼 풀에 데이터가 존재하지 않아 디스크 I/O가 필요한 경우 몇 배의 차이가 발생할 수 있다.

### 10.1.2.3 히스토그램과 인덱스
- 히스토그램과 인덱스는 완전히 다른 객체이다.
	- 그러나 MySQL 서버에서 인덱스가 부족한 통계 정보를 수집하기 위해 사용된다는 측면에서, 역할적인 부분의 공통점을 가진다고 볼 수 있다.
	- MySQL 서버에서는 쿼리의 실행 계획을 수립할 대 사용 가능한 인덱스들로부터 조건절에 일치하는 레코드 건수를 대략 파악하고 최종적으로 가장 나은 실행 계획을 선택한다.
	- 이때 조건절에 일치하는 레코드 건수를 예측하기 위해 옵티마이저는 실제 인덱스의 B-Tree를 샘플링해서 살펴본다.
		- 이 작업을 메뉴얼에서는 **"인덱스 다이브(Index Dive)"**라고 표현한다.
		- 407p 까지 

## 10.1.3 코스트 모델(Cost Model)

# 10.2. 실행 계획 확인
## 10.2.1 실행 계획 출력 포맷
## 10.2.2 쿼리의 실행 시간 확인

# 10.3 실행 계획 분석

## 10.3.1 id 칼럼

## 10.3.2 select_type 칼럼
### 10.3.2.1 SIMPLE
### 10.3.2.2 PRIMARY

### 10.3.2.3 UNION

### 10.3.2.4. DEPENDENT UNION

### 10.3.2.5 UNION RESULT

### 10.3.2.6 SUBQUERY

### 10.3.2.7 DEPENDENT SUBQUERY

### 10.3.2.8 DERIVED

### 10.3.2.9 DEPENDENT DERIVED

### 10.3.2.10 UNCACHEABLE SUBQUERY

### 10.3.2.11 UNCACHEABLE UNION

### 10.3.2.12 MATERIALIAED

## 10.3.3 table 칼럼

## 10.3.4 partitions 칼럼

## 10.3.5 type 칼럼

### 10.3.5.1 system
### 10.3.5.2 const

### 10.3.5.3 eq_ref

### 10.3.5.4 ref

### 10.3.5.6 fulltext

### 10.3.5.7 ref_or_null

### 10.3.5.8 index_subquery

### 10.3.5.9 range

### 10.3.5.10 index_merge

### 10.3.5.11 index


## 10.3.6 possible_key 칼럼

## 10.3.7 key 칼럼

## 10.3.8 key_len 칼럼

## 10.3.9 ref 칼럼

## 10.3.10 rows 칼럼

## 10.3.11 filtered 칼럼

## 10.3.12 Extra 칼럼

### 10.3.12.1 const row not found

### 10.3.12.2 Deleting all rows
### 10.3.12.3 Distinct

### 10.3.12.4 FirstMatch

### 10.3.12.5 Full scan on Null key

### 10.3.12.6 Impossible HAVING

### 10.3.12.7 Impossible WHERE

### 10.3.12.8 LooseScan

### 10.3.12.9 No matching min/max row

### 10.3.12.10 no matching row in const table

### 10.3.12.11 No matching rows after partition pruning

### 10.3.12.12 No tables used

### 10.3.12.13 Not exists

### 10.3.12.14 plan isn't ready yet

### 10.3.12.15 Range checked for each record(index map: N)

### 10.3.12.16 Recursive

### 10.3.12.17 Rematerialize

### 10.3.12.18 Select tables optimized away

### 10.3.12.19 Start temporary, End temporary

### 10.3.12.20 unique row not found

### 10.3.12.21 Using filesort

### 10.3.12.22 Using index(커버링 인덱스)

### 10.3.12.23 Using index condition

### 10.3.12.25 Using index for group-by

### 10.3.12.25 Using index for skip scan

### 10.3.12.26 Using join buffer(Block Nested Loop), Using join buffer(Batched Key Access), Using join buffer(...)

### 10.3.12.27 Using MRR

### 10.3.12.28 Using sort_union(), Using union(), Using intersect()

### 10.3.12.29 Using temporary

### 10.3.12.30 Using where

### 10.3.12.31 Zero limit