 ### InnoDB 버퍼풀이란?
 - InnoDB 스토리지 엔진에서 가장 핵심적인 부분으로, 디스크 데이터 파일이나 인덱스 정보를 메모리에 캐시해두는 공간.
 - 쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할도 같이 한다. 
	 - 일반적으로 데이터 변경 쿼리는 데이터 파일의 이곳저곳에 위치한 레코드를 변경하여, 랜덤한 디스크 작업을 발생시킨다. 
	 - 하지만 버퍼 풀에서 이러한 변경 데이터를 모아 처리하면 랜덤 디스크 작업의 횟수를 줄일 수 있다. 

## 버퍼 풀의 특성과 구조

 ### Page 단위로 구성
 - 버퍼 풀은 데이터를 Page 단위로 나누어 관리하며, 한 페이지에는 여러 로우(row) 가 속할 수 있다. 
 - 버퍼 풀 캐시의 효율적인 관리를 위해서, 버퍼 풀 내의 페이지는 링크드 리스트(linked list)로 관리한다. 
 - 일종의 LRU 알고리즘에 따라 잘 사용 되지 않는 데이터 페이지는 캐시에서 제거하는 방식으로 버퍼 풀을 관리한다.
	 - [출처](https://flashsql.github.io/innodb-doc-kr/blog/innodb/5.1.buffer-pool.html)

 ### 버퍼 풀 자료구조
![[버퍼 풀 블록에 있는 리스트의 종류.png]]
1. 프리 리스트(Free LIst)
	- 버퍼 풀에서 현재 비어 있는 페이지들의 list.
	- 사용자의 쿼리가 새롭게 디스크의 데이터 페이지를 읽어와야 하는 경우 사용됨.
2. LRU 리스트(Least Recently Used)
	- ![[LRU List]]
3. 플러시 리스트(Flush List) ^FlushList
	- Dirty page를 찾기 위한 목적의 내부적인 InnoDB 데이터 구조.
		- Dirty page : 아직 디스크에 동기화 되지 않은 데이터를 가진 페이지. 
	- 데이터 변경이 일어난 페이지들을 관리하고, 적절히 flush 하기 위한 list.
	- 데이터가 변경되면 InnoDB는 변경 내용을 [[리두 로그]]에 기록하고 버퍼 풀의 데이터 페이지에도 변경 내용을 반영.
	- 그래서 리두 로그의 각 엔트리는 특정 데이터 페이지와 연결된다. 
		- 하지만 리두 로그가 디스크로 기록됐다고 해서, 데이터 페이지가 디스크로 기록됐다는 것을 항상 보장하지는 않고, 때때로 반대 경우도 발생 가능.
			- InnoDB 스토리지 엔진은 [[체크 포인트]] 를 발생시켜 디스크의 리두 로그와 데이터 페이지의 상태를 동기화 하게 된다. 
			- 체크 포인트는 MySQL 서버가 시작될 때, InnoDB 스토리지 엔진이 리두 로그의 어느 부분부터 복구를 실행 할지 판단하는 기준점을 만드는 역할이다. 

---

## 버퍼 풀의 크기 설정

[[일단 생략]]

## 버퍼 풀과 [[리두 로그]]
- InnoDB의 버퍼 풀과 [[리두 로그]]는 매우 밀접한 관계가 있음.
	- 특히 버퍼 풀의 [[쓰기 버퍼링]] 기능에 대한 이해를 위해 버퍼 풀과 리두 로그의 관계를 이해할 필요.

![[InnoDB 버퍼 풀과 리두 로그의 관계.png]]

![[리두 로그#리두 로그와 버퍼 풀의 관계]]

---

## 버퍼 풀 플러시(Buffer Pool Flush)

- InnoDB 스토리지 엔진은 버퍼 풀에서 더티 페이지들을 성능상 악영향 없이 디스크에 동기화하기 위해 백그라운드에서 플러시 기능을 실행한다.
	- 버퍼 풀 플러시는 다음의 두 가지로 구성된다.
		- 플러시 리스트 플러시
		- [[LRU List]] 플러시
	 - 그런데 MySQL 8.0 버전부터는 더티 페이지를 디스크에 동기화 할 때, 디스크 쓰기 폭증 현상 같은 것이 줄었으므로, 굳이 시스템 변수 조정할 필요가 없다. 
		 - MySQL 5.6 버전 까지는 InnoDB의 더티 페이지 플러시 기능이 그다지 부드럽지 않았다. 
---
 ## [[InnoDB 버퍼 풀#^FlushList|플러시 리스트]] 플러시
 
 ### 플러시 리스트 플러시의 개념과 필요성
 
- 플러시 리스트 등록된 더티 페이지 중 오래전에 변경된 데이터 페이지 순서대로 디스크에 동기화하는 작업을 `플러시 리스트 플러시`라고 한다.
		- InnoDB에서 [[리두 로그]] 공간의 재활용을 위해 주기적으로 오래된 리두 로그 엔트리를 비워주어야 한다.
		- 이를 위해 리두 로그 엔트리에 대응하는 버퍼 풀의 더티 페이지들을 먼저 디스크에 동기화 해야 하기 때문에, 플러시 리스트 플러시가 일어난다.(Real MySQL의 설명)

 ### 플러시 리스트 플러시에 대한 개념과 관련 시스템 변수

목록 만 정리하고 세부 내용은 [[일단 생략]]

 - 클리너 스레드(Cleaner Thread)


- 버퍼 풀의 더티 페이지 비율

- InnoDB I/O 작업 수용량 설정과 버퍼 풀 플러시의 관계


- 어댑티브 플러시(Adaptive flush)

- 인접 페이지 묶어 쓰기 설정

---

 ## LRU 리스트 플러시

- LRU 리스트에서 사용 빈도가 낮은 데이터 페이지들을 제거해 새로운 공간을 만들기 위한 플러시 함수.
	- InnoDB 스토리지 엔진은 LRU 리스트의 끝부분부터, 설정한 스캔 개수 만큼의 페이지를 스캔한다.
		- 이 스캔 개수는 `innodb_lru_scan_depth 시스템 변수`로 설정한다.
	- InnoDB 스토리지 엔진은 스캔 과정 중에 더티 페이지는 디스크에 동기화하게 하며, 클린 페이지는 즉시 Free List로 페이지를 옮긴다. 
	- 이 스캔 과정은 버퍼 풀 인스턴스 별로 일어나기 때문에, 실질적으로 LRU 리스트 스캔은 (`innodb_buffer_pool_instance` * `innodb_lru_scan_depth`) 수 만큼 일어난다. 

---

## 버퍼 풀 상태 백업 및 복구
- DB를 사용하기 전, 워밍업 시키기 위해 버퍼 풀 상태 백업 및 복구를 수행한다. 

 ### 워밍업이란?
- 쿼리의 응답 속도 향상을 위해 디스크의 데이터를 버퍼 풀에 적재 해 놓은 상태나 그 상태를 만들기 위한 행위
	- 버퍼 풀은 디스크 데이터에 대한 캐시 역할을 수행하여 쿼리 응답속도를 비약적으로 늘린다. 
	- 때문에 MySQL 서버를 초기화해서 버퍼 풀이 초기화되면, 서버 시작 시 쿼리 응답속도가 평상시보다 1/10 정도로 떨어질 수 있다.
		- 때문에 MySQL 5.5 까지는 강제 워밍업을 위해 주요 테이블과 인덱스를 한 번 씩 풀 스캔하고 서비스를 오픈했다.

 ### 버퍼 풀 상태 백업 및 복구 명령어
- MySQL 5.6 버전부터 버퍼 풀 덤프 및 적재 기능이 도입되어, 서비스를 셧다운 하기 전에 서비스 중인 버퍼 풀의 상태를 백업할 수 있게 되었다.
- `innodb_buffer_pool_dump_now 시스템 변수`를 이용해 현재 InnoDB 버퍼 풀의 상태를 백업
- `innodb_buffer_pool_load_now 시스템 변수`를 이용해 백업한 버퍼 풀의 상태를 불러올 수 있다.

 ### 버퍼 풀 복구 현황 확인 및 복구 강제 종료 명령어
 - 버퍼 풀의 백업은 데이터 페이지의 메타 정보만을 저장하여 빠르게 수행된다.
- 하지만 해당 백업의 메타 정보로 실제 데이터 페이지를 적재하는 작업은 버퍼 풀의 크기에 따라 오랜 시간이 걸릴 수 있다.
- `innodb_buffer_pool_dump_status` 로 현재 버퍼 풀 복구 진행 정도를 확인 할 수 있다.
	``` SHOW STATUS LIKE 'Innodb_buffer_pool_dump_status' \G ```
- 버퍼 풀 적재 작업이 너무 오래 걸려서 멈추고 싶으면 `innodb_buffer_pool_load_abort 시스템 변수`로 강제 종료할 수 있다.
	```SET GLOBAL innodb_buffer_pool_load_abort = ON; ```

 ### 버퍼 풀 자동 백업 및 복구 기능
 - InnoDB 스토리지 엔진은 버퍼 풀 자동 백업 및 복구 기능을 제공한다.
 - `inno_buffer_pool_dump_at_shutdown`와 `innodb_buffer_pool_load_at_startup` 설정을 MySQL 서버의 설정 파일에 넣어두면 된다. 

>[!note]
>버퍼 풀 백업은 ib_buffer_pool 파일에 기록되는데, 스토리지 엔진이 복구 시, 실제 존재하지 않는 데이터 페이지에 대한 정보가 파일에 명시되면, 그냥 무시하고(오류 발생 X), 있는 데이터 파일만 적재한다.

---

## 버퍼 풀의 적재 내용 확인

- MySQL 서버의 information_schema 데이터베이스의 innodb_buffer_page 테이블을 통해 InnoDB 버퍼 풀의 메모리에 어떤 페이지가 적재돼 있는지 확인 할 수 있었다.
	- 이 기능은 MySQL 5.6 버전부터 지원 되었으나, 버퍼 풀이 큰 경우 이 테이블 조회의 부하로 서비스 쿼리가 많이 느려지는 문제가 발생되었다. 
	- 그래서 실 서비스에서 해당 방법을 사용하는 것이 거의 불가능 했다.
- 그래서 MySQL 8.0 버전부터는 information_schema DB의 innodb_cached_indexes 테이블이 추가 되어, 테이블의 인덱스 별로 데이터 페이지가 얼마나 InnoDB 버퍼 풀에 적재돼있는지 확인할 수 있다. 
예제 : [[일단 생략]]

- MySQL 서버는 아직 개별 인덱스별로 전체 페이지가 몇 개인지는 사용자에게 알려주지 않는다.

---






## 참조
[버퍼 풀의 플러시 리스트 구조-중국어 사이트]([Innodb 버퍼 풀 연동 목록 플러시-Tencent Cloud Developer Community-Tencent Cloud](https://cloud.tencent.com/developer/article/1670731))
[공식 문서]([MySQL :: MySQL 8.0 레퍼런스 매뉴얼 :: 15.5.1 버퍼 풀](https://dev.mysql.com/doc/refman/8.0/en/innodb-buffer-pool.html))
[공식 문서 정리한 벨로그]([Mysql InnoDB(1) - In-Memory Structure(Buffer Pool) (velog.io)](https://velog.io/@lpiecel/Mysql-InnoDB1-In-Memory-StructureBuffer-Pool))