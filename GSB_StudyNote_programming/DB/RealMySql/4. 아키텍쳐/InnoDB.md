
# InnoDB 스토리지 엔진의 장점

 ### 레코드 기반 잠금 제공
 - MySQL에서 사용할 수 있는 스토리지 엔진 중 거의 유일하게 레코드 기반 잠금 제공

 ### 높은 동시성 처리와 안정적이고 뛰어난 성능
 - 레코드 기반 잠금 처리로 인해 높은 동시성 처리와 안정적이고 뛰어난 성능이 가능.


# InnoDB 스토리지 엔진 아키텍처 ^InnoDbArchitecture

 ### InnoDB 아키텍처의 개략적인 구조
 ![[InnoDB 구조.png]]

# InnoDB의 주요 특징

 ## 프라이머리 키에 의한 클러스터링
 - InnoDB의 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링 되어 저장된다. 
	 - 즉, 프라이머리 키 값의 순서대로 디스크에 저장된다.
	 - 모든 세컨더리 인덱스는 레코드의 주소 대신 프라이머리 키의 값을 논리적인 주소로 사용한다.
	 - 프라이머리 키를 이용한 레인지 스캔은 상당히 빨리 처리될 수 있다.
	 - 결과적으로 쿼리의 실행 계획에서 프라이머리 키는 기본적으로 다른 보조 인덱스에 비해 비중이 높게 설정된다.
		 - 오라클 DBMS의 IOT(Index organized table)와 동일한 구조가 InnoDB에서는 일반적인 테이블 구조이다. 
- cf) [[MyISAM]] 스토리지 엔진에서는 클러스터링 키를 지원하지 않는다. 
---

 ## 외래 키 지원
 - 외래 키에 대한 지원은 InnoDB 스토리지 엔진 레벨에서 지원하는 기능이다.
	 - 때문에 MyISAM이나 MEMORY 테이블에서는 사용할 수 없다. 
 - InnoDB에서 외래 키로 인한 추가 작업과 제약 사항이 있으므로 개발할 때 주의할 필요가 있다. 
	 - InnoDB에서 외래 키는 부모 테이블과 자식 테이블 모두 해당 칼럼에 인덱스 생성이 필요
	 - 변경 시에 반드시 부모 테이블이나 자식 테이블에 데이터가 있는지 체크하는 작업이 필요
		 - 잠금이 여러 테이블로 전파되고, 데드락이 발생할 때가 많다. 
 - 이런 외래 키 관계 체크 작업은 `foreign_key_checks 시스템 변수` (on/off)로 일시적으로 비활성화 할 수 있다. 
	-  서비스에 문제가 있어서 긴급하게 조치를 취해야 할 경우, 사용해볼 수 있는 옵션이나, 여러 주의 사항이 존재한다.
	- 외래 키 체크를 일시적으로 중지한 상태에서 외래 키 관계를 가진 테이블의 레코드를 변경했다면, 반드시 해당 외래 키 관계에 있는 테이블에 추가 변경 작업을 해서 일관성을 맞춰준 다음, 외래 키 체크 활성화를 해야 한다. 
	- 또한 `foreign_key_checks 시스템 변수`가 비활성화 되면, 외래 키 관계의 부모 테이블에 대한 작업(On Delete/On Update 옵션)도 무시하게 된다.
- 결국 외래 키 체크를 일시적으로 해제했다고 해서 외래 키 관계가 깨진 상태로 계속 유지해도 된다는 것은 아니니 반드시 외래 키 관계에 신경 써야 한다.

> [!note] `foreign_key_checks` 시스템 변수는 적용범위(Scope)를 GLOBAL과 SESSION 모두로 설정 가능한 변수다. 그래서 이런 작업을 할 때는 반드시 현재 작업을 실행하는 세션에서만 외래 키 체크 기능을 멈추게 해야 한다. SESSION 키워드를 명시하지 않으면 자동으로 현재 세션의 설정만 변경한다.  

---
 ## MVCC(Multi Version Concurrency Control)

 ### MVCC 란?
 - 하나의 레코드에 대해 여러 개의 버전을 동시에 관리함으로써, 잠금을 사용하지 않는 일관된 읽기를 제공하기 위한 기능.
 - 일반적으로 레코드 레벨의 트랜잭션을 지원하는 DBMS에서 제공하는 기능이다.
 - InnoDB에서는 [[언두 로그(Undo Log)]]를 이용해 이 기능을 구현한다. 

 ### InnoDB 스토리지 엔진을 사용하는 MySQL에서 MVCC의 작동 예시

[[일단 생략]](책 101P)



---

 ## 잠금 없는 일관된 읽기(Non-Locking Consistent Read)
 
  ### InnoDB에서 [[InnoDB#MVCC(Multi Version Concurrency Control)|MVCC]]로 구현되는 잠금 없는 일관된 읽기
  - InnoDB 스토리지 엔진에서는 MVCC 기술을 이용해 잠금을 걸지 않고 읽기 작업을 수행한다. 
  - 잠금을 걸지 않기 때문에 InnoDB에서 읽기 작업은 다른 트랜잭션이 가지고 있는 잠금을 기다리지 않고, 읽기 작업이 가능하다. 
	  - [[격리수준]]이 SERIALIZABLE이 아닌 READ_UNCOMMITED, READ_COMMITED, REPEATABLE_READ 수준인 경우 INSERT와 연결되지 않은 **순수한** 읽기(SELECT) 작업은 다른 트랜잭션의 변경 작업과 상관 없이 항상 잠금을 대기하지 않고 바로 실행된다. 
	  ![[InnoDB의 잠금 없는 일관된 읽기 예시.png]]
	- 한 트랜잭션이 오랜 시간 동안 활성화 될 경우, 이러한 일관된 읽기를 위해 언두 로그를 삭제하지 못하고 계속 유지하게 되어, MySQL 서버가 느려지거나 문제가 발생하기도 한다.
		- 때문에 트랜잭션이 시작됐다면 가능한 빨리 롤백이나 커밋을 통해 트랜잭션을 완료해주어야 한다. 
---

 ## 자동 데드락 감지
 
 ### InnoDB의 [[데드락]] 감지 스레드
 - InnoDB 스토리지 엔진에는 내부적으로 잠금이 교착 상태에 빠지지 않았는지 체크하기 위한 용도로 잠금 대기 목록을 그래프(Wait-for List) 형태로 관리한다.
 - InnoDB에 존재하는 데드락 감지 스레드가 주기적으로 잠금 대기 그래프를 검사해 교착 상테에 빠진 트랜잭션이 있는지 찾는다. 
	 - 교착 상태에 빠진 트랜잭션이 있을 경우, 그 중 하나를 강제 종료하여 해결하는데, 강제 종료 대상을 선정하는 기준은 트랜잭션의 언두로그 양이다.
		 - 언두로그 양이 작은 레코드가 롤백 처리 내용이 적기 때문에, 작업량이 적고 서버 부하도 덜 유발하여 일반적으로 롤백의 대상이 된다. 

 ### 상위 레이어 잠금 감지 설정
 - InnoDB 스토리지 엔진은 상위 레이어인 MySQL 엔진에서 관리되는 테이블 잠금(LOCK TABLES 명령으로 잠긴 테이블)은 볼 수 없다. 
	 - 때문에 데드락 감지가 불확실 할 수도 있다.
	 - `innodb_table_locks 시스템 변수`를 활성화하면 InnoDB에서 상위 레이어인 MySQL 엔진의 테이블 레벨 잠금까지 감지할 수 있다.
		 - 특별한 이유가 없으면 `innodb_table_lock 시스템 변수`를 활성화 하는 것이 좋다.

 ### 데드락 감지 스레드 비활성화
 - 일반적인 서비스에서 데드락 감지 스레드의 작업은 부담이 크지 않지만, 동시 처리 스레드가 매우 많아지거나 각 트랜잭션이 가진 잠금의 개수가 많아지는 등으로 데드락 감지 스레드의 작업이 느려지는 경우가 발생할 수 있다. 
	 - 데드락 감지 스레드는 잠금 목록을 검사해야 하기 때문에, 검사 작업 도중에 잠금 상태가 변경되지 않도록 잠금 목록이 저장된 리스트(잠금 테이블)에 새로운 잠금을 걸고 작업을 진행한다.
	 - 이 때문에 데드락 감지 스레드가 느려지면 서비스 쿼리를 진행하는 스레드가 더 이상 작업을 처리하지 못하고 대기하면서 서비스에 악영향을 끼칠 수 있다.
- `innodb_deadlock_detect 시스템 변수`(on/off)를 통해 데드락 감지 스레드의 작동을 비활성화 할 수 있다.
	- 그러나 당연히 데드락 감지 스레드를 비활성화 하면, 데드락 발생시 무한 대기가 발생하게 된다.
	- 이를 방지하기 위해 잠금을 설정한 시간 동안 획득하지 못하면 쿼리를 실패시키고 에러를 반환하는 루틴이 존재한다. 
		- `innodb_lock_wait_timeout 시스템 변수` (초 단위)를 통해 이 설정 시간을 변경할 수 있다. 
		- 만약 데드락 감지 스레드의 기능을 off한다면, `innodb_lock_wait_timeout 시스템 변수` 의 시간을 디폴트 값(50초) 보다 낮게 변경하여 사용하는 것이 좋다. 
---
 ## 자동화된 [[장애 복구]]
 - InnoDB에는 손실이나 장애로부터 데이터를 보호하기 위한 여러 메커니즘이 존재.
 - 이러한 메커니즘으로 MySQL 서버가 시작될 때, 완료되지 못한 트랜잭션이나 디스크에 일부만 기록된(Partial write) 데이터 페이지 등에 대한 일련의 복구작업이 자동으로 진행된다.

 ### 자동 복구 실패시 강제 복구 사용하는 법
 - InnoDB 스토리지 엔진 문제로 데이터 파일 손상이나 MySQL 서버 시작 실패가 일어나는 일은 거의 없으나, MySQL 서버와 무관하게 데이터 파일이 손상되거나 서버 하드웨어 이슈로 InnoDB 스토리지 엔진이 자동으로 복구를 못하는 경우가 발생할 수 있다.
 - InnoDB 데이터 파일은 MySQL 서버 시작 시 항상 자동 복구를 수행하는데, 이 때 자동 복구에 **실패**하면 자동 복구를 멈추고 **MySQL 서버를 종료**시킨다. 
 - 이럴 때는 `innodb_force_recovery 시스템 변수`를 설정해서 MySQL 서버를 시작해야 한다.
	 - 이 `innodb_force_recovery 시스템 변수`는 0~6까지 설정할 수 있는데(0은 OFF), 각 번호마다 다른 처리 루틴이 배정되어 있다.
		 - 번호가 올라갈 수록 심각한 데미지를 복구하는 루틴이다. 
	 - 해당 변수별 설정에 대한 설명은 [[일단 생략]] 책 106p~107p
---

 ## [[InnoDB 버퍼 풀]]

![[InnoDB 버퍼 풀]]

---
 ## [[Double Write Buffer]]
 ![[Double Write Buffer]]
---

 ## [[언두 로그]]
 ![[언두 로그]]
---

 ## [[체인지 버퍼]]
 ![[체인지 버퍼]]
---

 ## [[리두 로그]]
 ![[리두 로그]]
---

 ## [[어댑티브 해시 인덱스]]
 ![[어댑티브 해시 인덱스]]
---

