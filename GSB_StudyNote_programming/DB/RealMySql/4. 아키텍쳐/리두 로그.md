 ## 리두 로그(Redo Log)란?
 - DB에 관련된 모든 변경 사항을 보관하는 Disk-based 자료구조로, 시스템 Crush나 장애가 발생했을 때, 데이터 파일에 기록되지 못한 데이터를 잃지 않게 해주는 [[로그 파일]].

 ## 리두 로그의 데이터 보호 작동 메커니즘
 -  SQL의 결과나 low-level API 요청 등으로 일어나는 모든 데이터 변경 사항은 **먼저** 리두 로그에 기록되고, 그 후에 데이터 파일에 반영된다. 
	 - 그래서 일부 DBMS에서 리두 로그를 WAL(Write Ahead Log, 먼저 기록하는 로그)라고 부르기도 한다.
	 - 리두 로그는 디스크 쓰기의 비효율성으로 인한 한계를 보완하기 위한 것으로, 상대적으로 쓰기 비용이 낮은 자료 구조로 이루어져 있다.
		 - 거의 모든 DBMS에서 데이터 파일 구성은 쓰기보다 읽기 성능을 고려한 자료구조로 이루어져 있기 때문에, 데이터 파일 쓰기는 디스크의 랜덤 액세스가 필요하여, 비용이 크다. 이로 인해 즉각적인 디스크 쓰기는 비효율적인데, 리두로그는 내구성을 위해 디스크에 기반하면서도, 즉각적인 쓰기 행위를 보완하기 위한 것이기 때문에 낮은 쓰기 비용이 요구된다. 
- 리두 로그에 기록되는 데이터는 영향을 받는 레코드의 관점에서 인코딩 되며, 이 데이터를 통칭해서 `리두`라고 한다. 
 - 리두 로그는 변경 사항의 기록을 통해 데이터베이스 시스템이 비정상적으로 종료되었을 때, 이전에 기록된 변경 사항을 재실행하여 데이터를 복구하거나, 변경 사항을 데이터 파일에 반영하기 전의 상태로 복구 할 수 있도록 한다. 
	 - DB의 내구성, ACID의 D와 관련
 - 또 리두 로그는 [[DB 복제(Database Replication)]]에서 주 복제본에서 발생한 변경 사항을 전파하여 복제를 통한 데이터 동기화 과정을 설정하는데 활용되기도 한다. 
 - DB 서버는 ACID도 중요하지만, 성능도 중요하기 때문에 리두 로그를 버퍼링할 수 있는 [[InnoDB 버퍼 풀]]이나 리두 로그를 버퍼링 할 수 있는 로그 버퍼 같은 자료구조도 가지고 있다. 

---
 ## 리두 로그의 구조
![[InnoDB 버퍼 풀과 리두 로그의 관계.png]]

 - 리두 로그는 1개 이상의 고정 크기 파일을 **연결**해서 **순환 고리**처럼 사용한다.
	 - 즉, 데이터 변경이 계속 발생하면 리두 로그 파일에 기록됐던 로그 엔트리는 어느 순간 다시 새로운 로그 엔트리로 덮어 쓰인다. 
 - 단, 아직 기록되지 않은 리두를 덮어쓰면 안되기 때문에, 리두 로그에서는 리두가 활성화 된 상태(Active Redo Log)인지, 아닌지를 구분한다.
	 - 활성화 되었다는 것은, 아직 디스크에 플러시 되지 않은 변경 사항을 추적하고 있다는 뜻이다.
	 - Real MySQL에서는 리두 로그의 활성화 상태를 위의 그림처럼 화살표로 가리키고 있는 상태로 설명한다. 
		 - 이에 관해 Bing GPT한테 물어봤는데 애매하게 대답.
			 - Q : 리두 로그가 활성화 되었다는 것을 곧, 버퍼풀에 있는 플러시 리스트를 포인터로 가리키고 있는 것과 같다(논리적으로 등치)라고 이해해도 돼겠습니까?
			 - A : 리두 로그가 활성화되었다는 것은, MySQL이 현재 처리 중인 트랜잭션에 대한 변경 사항을 추적하고 있다는 것을 의미합니다. 이러한 변경 사항은 버퍼 풀의 “dirty” 페이지, 즉 변경된 데이터 페이지에 대응됩니다. 
			 - 플러시 리스트는 이러한 “dirty” 페이지를 추적하며, 이 페이지들은 나중에 디스크로 플러시되어야 합니다. 따라서, 리두 로그가 활성화되었다는 것과 플러시 리스트가 “dirty” 페이지를 추적하고 있다는 것 사이에는 밀접한 관계가 있습니다. 
			 - 그러나 이 두 가지는 서로 다른 목적을 가지고 있습니다. 리두 로그는 데이터의 일관성을 유지하고 장애 복구를 가능하게 하는 반면, 플러시 리스트는 변경된 데이터 페이지를 추적하고 이러한 페이지를 디스크로 플러시하는 데 사용됩니다. 따라서, 이 둘은 서로 다른 역할을 수행하며, 각각의 역할은 InnoDB의 전체 작동 방식에 중요한 부분을 차지합니다.
- 또, 리두 로그를 관리하기 위해 LSN(Log Sequence Number)를 부여한다.
	- 리두 로그 파일 공간은 계속 순환되어 재사용 되지만, LSN을 부여하기 때문에 매번 기록될 때마다 증가된 로그 포지션을 갖는다.

---
 ## 리두 로그와 버퍼 풀의 관계
- InnoDB 스토리지 엔진은 주기적으로 [[체크 포인트]] 이벤트를 발생시켜 리두 로그와 [[InnoDB 버퍼 풀|버퍼 풀]]의 더티페이지를 디스크로 동기화 시킨다.
	- 이렇게 발생한 체크 포인트 중 가장 최근 체크 포인트 지점의 LSN이 활성 리두 로그 공간의 시작점이 된다.
		- 하지만 활성 리두 로그 공간의 마지막은 계속해서 증가하기 때문에 체크 포인트와 무관하다.
	- 가장 최큰 체크 포인트의 LSN과 마지막 리두 로그 엔트리의 LSN의 차이를 `체크 포인트 에이지(Checkpoint Age)`라고 한다. 
		- 즉 체크포인트 에이지는 활성 리두 공간의 크기를 말한다. 
- InnoDB 버퍼 풀의 더티 페이지는 특정 리두 로그 엔트리와 관계를 가지고, 체크 포인트가 발생하면 체크 포인트 LSN보다 작은 리두 로그 엔트리와 관련된 더티 페이지는 모두 디스크로 동기화 해야 한다. 
	- 물론 당연히 체크 포인트 LSN 보다 작은 LSN 값을 가진 리두 로그 엔트리도 디스크로 동기화 해야 한다.
 ### 리두 로그와 버퍼 풀 크기 비율 설정 
 [[일단 생략]] 112p
---
 ## 리두 로그 복구 시나리오 예시
 Real MySQL 1권 132p
 [[일단 생략]]

---
 ## 리두 로그 적정 크기 설정
 132p
 [[일단 생략]]
 ---
## 리두 로그 아카이빙
---
## 리두 로그 활성화 빛 비활성화

## 참조
[리두 로그의 자료구조](https://qiita.com/kyou-0576/items/f581e5ec0a982a4e7100)
[공식 문서](https://dev.mysql.com/doc/refman/8.0/en/innodb-redo-log.html)
