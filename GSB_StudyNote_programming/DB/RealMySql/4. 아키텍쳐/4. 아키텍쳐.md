

# MySql의 전체 구조

MySql 서버는 
	- 머리 역할을 하는 **MySql 엔진**
	- 손과 발의 역할을 하는 **스토리지 엔진**
으로 구성되어 있다. 

---

# 4.1 MySQL 엔진 아키텍처

![[MySQL 서버 아키텍처.png]]

## 4.1.1.1 MySQL 엔진

클라이언트로부터 요청받은 SQL문장을 분석하거나 최적화 하는 처리를 수행하는 부분.

- [[커넥션 핸들러]]
	- 클라이언트로부터의 접속 및 쿼리 요청을 처리
- SQL 인터페이스
- SQL 파서 및 전처리기
- SQL [[옵티마이저]] : 최적화된 실행 계획을 수립
- 캐시 및 버퍼
-
## 4.1.1.2 스토리지 엔진

실제 데이터를 디스크 스토리지에 **저장**하거나 디스크 스토리지로부터 데이터 **읽기**를 담당하는 부분

- MySQL 서버에서 MySQL 엔진은 하나지만, 스토리지 엔진은 여러 개를 동시에 사용할 수 있다. 
	- 각 테이블마다 해당 테이블이 사용할 스토리지 엔진을 지정할 수 있다.
	``` CREATE TABLE test_table (....) **ENGINE=INNODB**;```

## 4.1.1.3 핸들러 API
MySQL의 작동 방식은 앞에서 살펴본 바와 같이 MySQL 엔진이 클라이언트의 쿼리를 받아 해석하고, 그 데이터 처리를 스토리지 엔진에 위임한다. 
MySQL 엔진의 쿼리 실행기에서 데이터 쓰기, 읽기 작업 등을 각 스토리지 엔진에 요청할 때, 이러한 요청을 [[핸들러(Handler)]]요청이라고 하고, 해당 요청을 처리하는 API를 핸들러 API라고 한다. 
- 다시 말해 MySql 엔진과 스토리지 엔진 사이에서 미리 정의된 인터페이스 규약을 말함. 
- 핸들러 API의 호출 횟수는 ```SHOW GLOBAL STATUS LIKE 'Handler%';``` 명령어로 확인 가능.
---
## 4.1.2 MySQL 스레딩 구조
![[MySQL 스레드 모델에 따른 처리 프로세스.png]]

- MySQL 서버는 프로세스 기반이 아니라 **스레드 기반**으로 작동
- 크게 **포그라운드(Foreground) 스레드**와 **백그라운드(Background) 스레드** 로 구성되어 있다. 
- MySQL 서버에서 실행 중인 스레드 목록은 performance_schema 데이터베이스의 threads 테이블을 통해 확인할 수 있다. 
-![[MySQL 현재 스레드 목록 보기 예제.png]]
- 전체 39개 중 36개가 백그라운드 스레드, 나머지 3개가 포어그라운드 스레드이다. 
- 이 중 마지막 'thread/sql/one_connection' 스레드만 실제 사용자의 요청을 처리하는 포그라운드 스레드이다. 
- 백그라운드 스레드의 개수는 MySQL 서버의 설정에 따라 가변적일 수 있다. 
- 동일한 이름의 스레드가 2개 이상씩 보이는 것은 MySQL 서버의 설정에 의해 여러 스레드가 동일 작업을 병렬로 처리하는 경우이다. 

>[!참고 :  엔터프라이즈 에디션의 스레드풀 모델]
>MySQL 엔터프라이즈 에디션에서는 스레드 모델 뿐만 아니라 [[스레드 풀(Thread Pool)]] 모델을 사용할 수 있다. (전통적인) 스레드 모델에서는 커넥션 별로 하나의 포그라운드 스레드가 생성되지만, 스레드 풀 모델에서는 커넥션과 포그라운드 스레드가 1:1 관계가 아니며, 하나의 스레드가 여러 개의 커넥션 요청을 담당한다. 

---
## 4.1.2.1 포그라운드 스레드(=클라이언트 스레드)

### 포그라운드 스레드란?
- DBMS의 **앞단**에서 **사용자**와 통신하는 것을 담당하는 스레드.
- 앞단에서 동작하기에 포그라운드 스레드라고 불리며, 또 사용자와 통신하기에 클라이언트 스레드라고도 불린다.
- 포그라운드 스레드는 (스레드 모델에서) 최소한 MySQL 서버에 접속된 클라이언트 수 만큼 존재하며, 각 클라이언트 사용자가 요청하는 쿼리 문장을 처리한다. 
### 포그라운드 스레드의 생명주기와 스레드 캐시

- 작업을 마치고 커넥션이 종료된 스레드는 스레드 캐시로 되돌아가는데, 이 때 스레드 캐시의 일정 개수 이상의 캐시가 이미 존재하면, (스레드 캐시 최대 갯수를 초과하면) 해당 스레드는 Close되어 반환된다. 
	- 이 스레드 캐시의 최대 개수는 thread_cache_size 시스템 변수로 관리된다. 
### 포그라운드 스레드의 역할
- 포그라운드 스레드는 데이터를 MySQL의 데이터 버퍼나 캐시로부터 가져온다. 
- 버퍼나 캐시에 데이터가 없는 경우에는 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 **읽어와서** 작업을 처리한다. 
- 스토리지 엔진에 따라 포그라운드 스레드가 수행하는 역할에 차이가 있다. 
	- [[MyISAM]] 테이블은 디스크 쓰기 작업까지 포그라운드 스레드가 처리한다. 
		- MyISAM 테이블은 트랜잭션을 지원하지 않는 스토리지 엔진. 간단한 데이터 쓰기 작업에 적합함. 
		- MyISAM도 지연된 쓰기가 있지만 일반적인 방식은 아님.
	- [[InnoDB]] 테이블은 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리하고, 나머지 버퍼로부터 디스크까지 기록하는 작업은 백그라운드 스레드가 처리.
---
## 4.1.2.2 백그라운드 스레드

- [[MyISAM]] 스토리지 엔진은 백그라운드 스레드를 사용하지 않는다(By GPT)


### InnoDB에서의 백그라운드 스레드

- [[InnoDB]]는 다음과 같은 여러 작업이 백그라운드 스레드로 처리된다.
	- 인서트 버퍼(Insert Buffer)를 병합하는 스레드
	- 로그를 디스크로 기록하는 스레드
	- InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
	- 데이터를 버퍼로 읽어 오는 스레드
	- 잠금이나 데드락을 모니터링 하는 스레드

- 상기의 작업들 모두 중요하지만, 그 중에서도 가장 중요한 것은 로그 스레드(Log Thread)와 버퍼의 데이터를 디스크로 내려쓰는 작업을 처리하는 쓰기 스레드(Write thread)이다. 
	- MySQL 5.5 부터 데이터 쓰기 스레드와 데이터 읽기 스레드의 개수를 2개 이상 지정할 수 있다. 
	- innodb_write_io_threads, innodb_read_io_threads 시스템 변수로 해당 스레드의 개수를 설정한다.
- InnoDB에서도 데이터를 읽는 작업은 주로 클라이언트 스레드에서 처리되기 때문에 읽기 스레드는 많이 설정할 필요가 없다. 
- 그러나 쓰기 스레드는 아주 많은 작업을 백그라운드로 처리하기 때문에 디스크를 최적으로 사용할 수 있을 만큼 충분히 설정하는 것이 좋다. 
	- 일반적인 내장 디스크를 사용할 때는 2~4 개 정도.
---
### 데이터 읽기, 쓰기 작업과 지연(버퍼링) 처리

- 사용자 요청을 처리하는 도중 데이터의 쓰기 작업은 지연되어 처리될 수 있다.
- 그러나 데이터의 읽기 작업은 절대 지연될 수 없다. 
- 일반적인 상용 DBMS에는 대부분 쓰기 작업을 버퍼링해서 일괄 처리하는 기능이 탑재되어 있으며, InnoDB 또한 이러한 방식으로 처리한다. 
	- 이러한 이유로 InnoDB에서는 INSERT, UPDATE, DELETE 쿼리로 데이터가 변경되는 경우 데이터가 디스크의 데이터 파일로 완전히 저장될 때 까지 기다리지 않아도 된다.
	
- MyISAM은 그렇게 처리하지 않고, 사용자 스레드가 쓰기 작업까지 함께 처리한다. 
	- 때문에 MyISAM에서 일반적인 쿼리는 쓰기 버퍼링 기능을 사용할 수 없다.
---
## 4.1.3 메모리 할당 및 사용 구조

![[MySQL 서버 메모리 사용 및 할당 구조.png]]

- MySQL에서 사용되는 메모리 공간은 크게 글로벌 메모리 영역과 로컬 메모리 영역으로 구분할 수 있다. 
- 글로벌 메모리 영역과 로컬 메모리 공간은 MySQL 내에 존재하는 많은 스레드들이 공유해서 사용하는 공간인지 여부에 따라 구분한다. 
---
### 4.1.3.1 글로벌 메모리 영역

- 글로벌 메모리 영역의 모든 메모리 공간은 MySQL 서버가 시작되며, 운영체제로부터 할당된다. 
	- 복잡한 부분이 있지만, 보통은 MySQL 시스템 변수에서 할당한 만큼 받는다고 생각하면 된다. 
- 일반적으로 클라이언트 스레드의 수와 무관하게 하나의 메모리 공간만 할당된다.
	- 단, 필요에 따라 2개 이상의 메모리 공간을 할당받을 수도 있지만, 이 때도 클라이언트의 스레드 수와 무관하다.
- 생성된 글로벌 영역은 (그 갯수와 무관하게) 모든 스레드에 의해 공유된다.
- 대표적 글로벌 메모리 영역
	- 테이블 캐시
	- InnoDB 버퍼 풀
	- InnoDB 어댑티브 해시 인덱스
	- InnoDB 리두 로그 버퍼
---
### 4.1.3.2 로컬 메모리 영역(=세션 메모리 영역, 클라이언트 메모리 영역)

- MySQL 서버 상에서 존재하는 클라이언트 스레드가 쿼리를 처리하는데 사용하는 메모리 영역
- 대표적 로컬 메모리 영역
	- 커넥션 버퍼
	- 조인 버퍼
	- 소트(sort) 버퍼
	- 바이너리 로그 버퍼
	- 네트워크 버퍼
	
- 클라이언트가 접속하면 MySQL 서버에서는 클라이언트 커넥션을 처리하기 위해 스레드를 하나 씩 할당하게 된다. 
	- 이 때문에 클라이언트 스레드가 사용하는 메모리 공간이라고 해서 클라이언트 메모리영역이라고도 하고, 클라이언트와 MySQL 서버 간의 커넥션을 세션이라고 하기 때문에 세션 메모리 영역이라고도 한다. 
- 로컬 메모리 영역은 각 클라이언트 **스레드별**로 **독립적으로 할당**되며, **절대 공유되어 사용되지 않는다.**
- 로컬 메모리 공간은 커넥션이 열려있는 동안 계속 할당되는 상태로 남아있는 공간(커넥션 버퍼, 결과 버퍼) 도 있고, 쿼리를 실행하는 순간에만 할당했다가 다시 해제하는 공간(소트 버퍼나 조인 버퍼)도 있다. 
	- 각 쿼리의 용도 별로 필요할 때만 공간이 할당되고, 필요하지 않은 경우 MySQL이 메모리 할당조차 하지 않을 수 있다. 
	- 로컬 메모리 공간도 서버에 부하를 줄 수 있기 때문에 적절한 메모리 공간 설정이 필요하다. 

---

## 4.1.4 플러그인 스토리지 엔진 모델

![[MySQL 플러그인 모델.png]]

- MySQL의 독특한 구조 중 대표적인 부분이 바로 플러그인 모델.
- 많은 기능들을 이미 만들어진 플러그인을 다운 받아 추가하거나, 직접 플러그인 방식으로 개발해 추가할 수 있다. 

![[MySQL엔진과 스토리지 엔진의 처리 영역.png]]
- 상기의 그림처럼 MySQL에서 쿼리가 실행되는 대부분의 작업이 MySQL 엔진에 의해 수행되고 마지막 데이터 읽기 쓰기 작업만 스토리지 엔진에 의해 처리된다. 
	- 때문에 사용자가 만약 새로운 용도의 스토리지 엔진을 만든다고 해도, DBMS의 전체 기능이 아닌 일부분의 기능만 수행하는 엔진을 작성하게 된다. 
- 각 처리 영역에서 '데이터 읽기/쓰기' 작업은 대부분 1건의 레코드 단위로 처리된다. 
	- 예를 들어 특정 인덱스의 레코드 1건 읽기, 마지막으로 읽은 레코드의 다음 또는 이전 레코드 읽기
---

![[핸들러(Handler)#핸들러(Handler) 란? whiatisHandler]]

---
### MySQL 서버(mysqld)에서 지원하는 스토리지 엔진

- ```SHOW ENGINES;``` 

![[MySQL 서버에서 지원하는 스토리지 엔진 조회.png]]
- Support 칼럼의 값
	- YES : MySQL 서버(mysqld)에 해당 스토리지 엔진에 포함되어 있고, 사용 가능으로 활성화 된 상태
	- DEFAULT : 'YES'와 동일한 상태이지만, 필수 스토리지 엔진임을 의미
		- 즉, 이 스토리지 엔진이 없으면 MySQL 이 시작되지 않을 수도 있다. 
	- NO : 현재 MySQL 서버에 포함이 되지 않았음을 의미.
	- DISABLED :  현재 MySQL 서버에는 포함이 됐지만 파라미터에 의해 비활성화 된 상태.

### 플러그인 모델의 이점

- 빌드된 스토리지 엔진을 추가함으로써, 재빌드 없이 MySQL 서버에서 스토리지 엔진을 사용할 수 있다.
	- MySQL 서버(mysqld)에 포함되지 않은 스토리지 엔진을 사용하려면, MySQL 서버를 다시 빌드(컴파일) 해야 한다. 
	- 하지만 MySQL 서버가 적절히 준비만 돼 있다면 플러그인 형태로 빌드된 스토리지 엔진 라이브러리를 다운로드 해서 끼워넣기만 하면 사용할 수 있다. 
- 플러그인 형태의 스토리지 엔진은 쉽게 업그레이드 가능
- 스토리지 엔진 뿐만 아니라 다양한 기능을 플러그인 형태로 추가 가능. 

- SHOW PLUGINS; 명령어로 설치된 플러그인 조회 가능.

## 4.1.5 컴포넌트

> 기존의 플러그인 아키텍처를 대체하기 위해 MySQL 8.0 부터 지원하는 아키텍처 구조

### 기존 플러그인 모델의 단점

	- 플러그인은 오직 MySQL 서버와 인터페이스 할 수 있고, 플러그인끼리는 통신할 수 없음.
	- 플러그인은 MySQL 서버의 변수나 함수를 직접 호출하기 때문에 안전하지 않음.
	- 플러그인은 상호 의존관계를 설정할 수 없어서 초기화가 어려움.

- 이러한 한계들을 극복하기 위해 컴포넌트 아키텍처 모델이 나옴.

---

## 4.1.6 쿼리 실행 구조

![[MySQL 쿼리 실행 구조.png]]

### 4.1.6.1 [[쿼리 파서(Query Parser)]]

- 쿼리 파서는 사용자 요청으로 들어온 쿼리 문장을 'MySQL이 인식할 수 있는 최소 단위의 어휘나 기호', 즉 `토큰` 으로 분리해 트리 형태의 구조로 만드는 작업을 수행한다. 
- 이 과정에서 쿼리 문장의 기본 문법 오류를 발견하고, 사용자에게 오류 메세지를 전달한다.
---
### 4.1.6.2 [[전처리기]]

- 파싱 과정에서 만들어진 파서 트리를 기반으로, 쿼리 문장에 구조적 문제점이 있는지 확인.
- 각 토큰을 테이블 이름이나 칼럼 이름, 또는 내장 함수와 같은 개체를 매핑한다.
	- 이 과정에서 해당 객체의 존재 여부와 객체의 접근 권한 등을 확인한다.
- 실제 존재하지 않거나 권한 상 사용할 수 없는 개체의 토큰은 여기서 걸러서, 오류 메세지를 전달한다. 
---
### 4.1.6.3 [[옵티마이저]]

- 옵티마이저는 사용자의 요청으로 들어온 쿼리 문장을 '저렴한 비용으로 가장 빠르게, 즉 **최적의 실행 계획을 수립**'하는 역할을 담당.
	- 즉, `DBMS의 두뇌`에 해당한다.
- 전달 된 파서 트리를 바탕으로, 필요하지 않은 조건 제거, 연산과정 단순화를 처리한다.
- 나아가 '어떤 순서로 테이블에 접근할 지', '인덱스를 사용할 지', '사용한다면 어떤 인덱스를 사용할 지', '정렬할 때 인덱스를 사용할 지 아니면 임시 테이블을 사용할 지' 와 같은 실행 계획을 수립한다.
- 단, 실행 계획을 수립하는 작업 자체 만으로도 대기 시간과 하드웨어 리소스를 점유하므로, 시간과 리소스에 제한을 두고 실행 계획을 선정해야 한다. 
- 옵티마이저가 실행 가능한 모든 실행 계획을 판단하지는 않는다. 
	- 만약 실행 계획으로 도출할 수 있는 경우의 수가 지나치게 많을 때는 각각의 비용 산정 및 최적의 실행 계획을 선택하기 까지 시간이 오래 걸리기 때문.
	- 때문에 옵티마이저가 선택한 **최적의 실행 계획이 항상 최상의 실행 계획이 아닐 가능성**이 존재한다.

---

### 4.1.6.4 [[실행 엔진]]

- 실행 엔진은 실행 계획을 핸들러를 통해 실행하는 역할을 담당.
	- 즉, 옵티마이저의 실행 계획에 따라, 핸들러를 호출하고, 그 결과를 다시 다른 핸들러로 전달해, 전체적인 쿼리 실행을 수행한다. 

- GROUP BY를 수행하는 예시 
	1. 실행 엔진이 핸들러에게 임시 테이블을 만들라고 요청 
	2. 다시 실행 엔진은 WHERE 절에 일치하는 레코드를 읽어오라고 핸들러에게 요청 
	3. 읽어온 레코드들을 1번에서 준비한 임시 테이블로 저장하라고 다시 핸들러에게 요청 
	4. 데이터가 준비된 임시 테이블에서 필요한 방식으로 데이터를 읽어 오라고 핸들러에게 다시 요청 
	5. 최종적으로 실행 엔진은 결과를 사용자나 다른 모듈로 넘김 
	
	=> 임시 테이블 생성 - WHERE 조건 일치하는 데이터 읽기 - 임시 테이블에 저장 - 다시 조건 수행 - 결과 전송​

---

### 4.1.6.5 핸들러(=스토리지 엔진)

![[핸들러(Handler)#핸들러와 스토리지 엔진 handlerAndStorageEngine]]

---
## 4. 1. 7 [[복제(Replication)]]
- MySQL 서버에서 복제는 매우 중요한 역할을 담당하며, 지금까지 많은 발전을 거듭해왔다.
- 이후 16장에서 살펴봄. 

---
## 4. 1. 8 [[쿼리 캐시(Query Cache)]]

![[쿼리 캐시(Query Cache)#쿼리 캐시란? aboutQueryCache]]

---

## 4.1.9 [[스레드 풀(Thread Pool)]]

- MySQL 에서는 기본적으로 엔터프라이즈 버전에만 스레드 풀 기능이 열려있지만, 따로 플러그인을 통해 스레드 풀 기능을 이용 할 수도 있다. 

![[스레드 풀(Thread Pool)#스레드 풀의 기능 functionOfThreadPool]]
![[스레드 풀(Thread Pool)#PlugIn 으로 지원하는 스레드 풀 threadPoolByPlugIn]]

---

## 4.1.10 트랜잭션 지원 메타 데이터

[[일단 생략]]


---

# 4.2 [[InnoDB]] 스토리지 엔진 아키텍처
![[InnoDB]]

---
## 4.2.13 [[InnoDB]]와 [[MyISAM]], MEMORY 스토리지 엔진 비교

---

## 4.3 [[MyISAM]] 스토리지 엔진 아키텍처

![[MyISAM#MyISAM 스토리지 엔진 아키텍처]]









---
## [[MySQL 로그 파일]]
![[MySQL 로그 파일]]

---
